<!DOCTYPE html>
<html>
<head>
<title>Bouncing Balls Simulation</title>
<style>
    body { margin: 0; overflow: hidden; background-color: #000; }
    canvas { display: block; }
</style>
</head>
<body>
<canvas id="canvas"></canvas>
<script>
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;

    function randomColor() {
        return `hsl(${Math.random() * 360}, 100%, 50%)`;
    }

    function randomIntFromRange(min, max) {
        return Math.floor(Math.random() * (max - min + 1) + min);
    }

    class Ball {
        constructor(x, y, radius, color, dx, dy) {
            this.x = x;
            this.y = y;
            this.radius = radius;
            this.color = color;
            this.velocity = { x: dx, y: dy };
            this.mass = this.radius * 0.5; // Mass is proportional to radius
        }

        draw() {
            ctx.beginPath();
            ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2, false);
            ctx.fillStyle = this.color;
            ctx.fill();
            ctx.closePath();
        }

        update(balls) {
            this.draw();

            // Wall collision
            if (this.x + this.radius > canvas.width || this.x - this.radius < 0) {
                this.velocity.x = -this.velocity.x;
            }
            if (this.y + this.radius > canvas.height || this.y - this.radius < 0) {
                this.velocity.y = -this.velocity.y;
            }
            
            // Prevent balls from getting stuck in walls
            if (this.x + this.radius > canvas.width) this.x = canvas.width - this.radius;
            if (this.x - this.radius < 0) this.x = this.radius;
            if (this.y + this.radius > canvas.height) this.y = canvas.height - this.radius;
            if (this.y - this.radius < 0) this.y = this.radius;


            // Ball-to-ball collision
            for (let i = 0; i < balls.length; i++) {
                if (this === balls[i]) continue;
                const dist = Math.hypot(this.x - balls[i].x, this.y - balls[i].y);

                if (dist - this.radius - balls[i].radius < 0) {
                    resolveCollision(this, balls[i]);
                }
            }

            this.x += this.velocity.x;
            this.y += this.velocity.y;
        }
    }

    function resolveCollision(ball, otherBall) {
        const xVelocityDiff = ball.velocity.x - otherBall.velocity.x;
        const yVelocityDiff = ball.velocity.y - otherBall.velocity.y;

        const xDist = otherBall.x - ball.x;
        const yDist = otherBall.y - ball.y;

        // Prevent accidental overlap of balls
        if (xVelocityDiff * xDist + yVelocityDiff * yDist >= 0) {
            const angle = -Math.atan2(otherBall.y - ball.y, otherBall.x - ball.x);

            const m1 = ball.mass;
            const m2 = otherBall.mass;

            const u1 = rotate(ball.velocity, angle);
            const u2 = rotate(otherBall.velocity, angle);

            const v1 = { x: u1.x * (m1 - m2) / (m1 + m2) + u2.x * 2 * m2 / (m1 + m2), y: u1.y };
            const v2 = { x: u2.x * (m1 - m2) / (m1 + m2) + u1.x * 2 * m1 / (m1 + m2), y: u2.y };

            const vFinal1 = rotate(v1, -angle);
            const vFinal2 = rotate(v2, -angle);

            ball.velocity.x = vFinal1.x;
            ball.velocity.y = vFinal1.y;

            otherBall.velocity.x = vFinal2.x;
            otherBall.velocity.y = vFinal2.y;
        }
    }
    
    function rotate(velocity, angle) {
        return {
            x: velocity.x * Math.cos(angle) - velocity.y * Math.sin(angle),
            y: velocity.x * Math.sin(angle) + velocity.y * Math.cos(angle)
        };
    }


    let balls = [];
    function init() {
        balls = [];
        for (let i = 0; i < 20; i++) {
            const radius = randomIntFromRange(10, 30);
            let x = randomIntFromRange(radius, canvas.width - radius);
            let y = randomIntFromRange(radius, canvas.height - radius);
            const color = randomColor();
            const dx = randomIntFromRange(-2, 2) || 1;
            const dy = randomIntFromRange(-2, 2) || 1;

            // Ensure balls don't spawn on top of each other
            if (i !== 0) {
                for (let j = 0; j < balls.length; j++) {
                    const dist = Math.hypot(x - balls[j].x, y - balls[j].y);
                    if (dist - radius - balls[j].radius < 0) {
                        x = randomIntFromRange(radius, canvas.width - radius);
                        y = randomIntFromRange(radius, canvas.height - radius);
                        j = -1; // Restart the check
                    }
                }
            }
            balls.push(new Ball(x, y, radius, color, dx, dy));
        }
    }

    function animate() {
        requestAnimationFrame(animate);
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        balls.forEach(ball => {
            ball.update(balls);
        });
    }

    init();
    animate();
    
    window.addEventListener('resize', () => {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        init();
    });

</script>
</body>
</html>